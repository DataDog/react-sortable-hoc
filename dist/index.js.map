{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/utils.js","../src/DragLayer/utils.js","../src/DragLayer/index.js","../src/Manager.js","../src/SortableContainer/index.js","../src/SortableElement/index.js","../src/SortableHandle/index.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = (function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar iteratorSymbol = Symbol.iterator;\n\t\tif (iteratorSymbol && (iteratorSymbol in target)) {\n\t\t\tvar iterator = target[iteratorSymbol](), step, pact, reject;\n\t\t\tfunction _cycle(result) {\n\t\t\t\ttry {\n\t\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (pact) {\n\t\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpact = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(pact || (pact = new Pact()), 2, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_cycle();\n\t\t\tif (iterator.return) {\n\t\t\t\tvar _fixup = function(value) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\t\titerator.return();\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t\tif (pact && pact.then) {\n\t\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t_fixup();\n\t\t\t}\n\t\t\treturn pact;\n\t\t}\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"value is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof Symbol !== \"undefined\") {\n\t\tvar asyncIteratorSymbol = Symbol.asyncIterator;\n\t\tif (asyncIteratorSymbol && (asyncIteratorSymbol in target)) {\n\t\t\tvar pact = new _Pact();\n\t\t\tvar iterator = target[asyncIteratorSymbol]();\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\treturn pact;\n\t\t\tfunction _resumeAfterBody(result) {\n\t\t\t\tif (check && !check()) {\n\t\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t\t}\n\t\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t\t}\n\t\t\tfunction _resumeAfterNext(step) {\n\t\t\t\tif (step.done) {\n\t\t\t\t\t_settle(pact, 1);\n\t\t\t\t} else {\n\t\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction _reject(error) {\n\t\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t\t}\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = (function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype[Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))] = function() {\n\t\treturn this;\n\t};\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import invariant from 'invariant';\n\nexport function arrayMove(array, from, to) {\n  // Will be deprecated soon. Consumers should install 'array-move' instead\n  // https://www.npmjs.com/package/array-move\n\n  array = array.slice();\n  array.splice(to < 0 ? array.length + to : to, 0, array.splice(from, 1)[0]);\n\n  return array;\n}\n\nexport function omit(obj, ...keysToOmit) {\n  return Object.keys(obj).reduce((acc, key) => {\n    if (keysToOmit.indexOf(key) === -1) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}\n\nexport const events = {\n  start: ['touchstart', 'mousedown'],\n  move: ['touchmove', 'mousemove'],\n  end: ['touchend', 'touchcancel', 'mouseup'],\n};\n\nexport const vendorPrefix = (function() {\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    // Server environment\n    return '';\n  }\n\n  // fix for: https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  // window.getComputedStyle() returns null inside an iframe with display: none\n  // in this case return an array with a fake mozilla style in it.\n  const styles = window.getComputedStyle(document.documentElement, '') || [\n    '-moz-hidden-iframe',\n  ];\n  const pre = (Array.prototype.slice\n    .call(styles)\n    .join('')\n    .match(/-(moz|webkit|ms)-/) ||\n    (styles.OLink === '' && ['', 'o']))[1];\n\n  switch (pre) {\n    case 'ms':\n      return 'ms';\n    default:\n      return pre && pre.length ? pre[0].toUpperCase() + pre.substr(1) : '';\n  }\n})();\n\nexport function closest(el, fn) {\n  while (el) {\n    if (fn(el)) {\n      return el;\n    }\n\n    el = el.parentNode;\n  }\n\n  return null;\n}\n\nexport function limit(min, max, value) {\n  return Math.max(min, Math.min(value, max));\n}\n\nfunction getPixelValue(stringValue) {\n  if (stringValue.substr(-2) === 'px') {\n    return parseFloat(stringValue);\n  }\n\n  return 0;\n}\n\nexport function getElementMargin(element) {\n  const style = window.getComputedStyle(element);\n\n  return {\n    top: getPixelValue(style.marginTop),\n    right: getPixelValue(style.marginRight),\n    bottom: getPixelValue(style.marginBottom),\n    left: getPixelValue(style.marginLeft),\n  };\n}\n\nexport function provideDisplayName(prefix, Component) {\n  const componentName = Component.displayName || Component.name;\n\n  return componentName ? `${prefix}(${componentName})` : prefix;\n}\n\nexport function getPosition(event) {\n  if (event.touches && event.touches.length) {\n    return {\n      x: event.touches[0].pageX,\n      y: event.touches[0].pageY,\n    };\n  } else if (event.changedTouches && event.changedTouches.length) {\n    return {\n      x: event.changedTouches[0].pageX,\n      y: event.changedTouches[0].pageY,\n    };\n  } else {\n    return {\n      x: event.pageX,\n      y: event.pageY,\n    };\n  }\n}\n\nexport function isTouchEvent(event) {\n  return (\n    (event.touches && event.touches.length) ||\n    (event.changedTouches && event.changedTouches.length)\n  );\n}\n\nexport function getEdgeOffset(node, parent, offset = {top: 0, left: 0}) {\n  if (!node) {\n    return undefined;\n  }\n\n  // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n  const nodeOffset = {\n    top: offset.top + node.offsetTop,\n    left: offset.left + node.offsetLeft,\n  };\n\n  if (node.parentNode === parent) {\n    return nodeOffset;\n  }\n\n  return getEdgeOffset(node.parentNode, parent, nodeOffset);\n}\n\nexport function getLockPixelOffset({lockOffset, width, height}) {\n  let offsetX = lockOffset;\n  let offsetY = lockOffset;\n  let unit = 'px';\n\n  if (typeof lockOffset === 'string') {\n    const match = /^[+-]?\\d*(?:\\.\\d*)?(px|%)$/.exec(lockOffset);\n\n    invariant(\n      match !== null,\n      'lockOffset value should be a number or a string of a ' +\n        'number followed by \"px\" or \"%\". Given %s',\n      lockOffset,\n    );\n\n    offsetX = parseFloat(lockOffset);\n    offsetY = parseFloat(lockOffset);\n    unit = match[1];\n  }\n\n  invariant(\n    isFinite(offsetX) && isFinite(offsetY),\n    'lockOffset value should be a finite. Given %s',\n    lockOffset,\n  );\n\n  if (unit === '%') {\n    offsetX = (offsetX * width) / 100;\n    offsetY = (offsetY * height) / 100;\n  }\n\n  return {\n    x: offsetX,\n    y: offsetY,\n  };\n}\n\nexport const NodeType = {\n  Anchor: 'A',\n  Button: 'BUTTON',\n  Canvas: 'CANVAS',\n  Input: 'INPUT',\n  Option: 'OPTION',\n  Textarea: 'TEXTAREA',\n  Select: 'SELECT',\n};\n","import {limit} from '../utils';\n\nexport function distanceRect(x, y, rect) {\n  // Take account of scroll\n  const pageXOffset = window.pageXOffset;\n  const pageYOffset = window.pageYOffset;\n\n  const left = rect.left + pageXOffset;\n  const right = rect.right + pageXOffset;\n  const top = rect.top + pageYOffset;\n  const bottom = rect.bottom + pageYOffset;\n  const dx = x - limit(left, right, x);\n  const dy = y - limit(top, bottom, y);\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function closestRect(x, y, containers) {\n  const distances = containers.map((container) =>\n    distanceRect(x, y, container.getBoundingClientRect()),\n  );\n  return distances.indexOf(Math.min(...distances));\n}\n\nexport function getDelta(rect1, rect2) {\n  return {\n    x: rect1.left - rect2.left,\n    y: rect1.top - rect2.top,\n  };\n}\n\nexport function updateDistanceBetweenContainers(\n  distance,\n  container1,\n  container2,\n) {\n  const {x, y} = distance;\n  const delta = getDelta(\n    ...[container1, container2].map((cont) =>\n      cont.container.getBoundingClientRect(),\n    ),\n  );\n  const scrollDX =\n    container2.scrollContainer.scrollLeft -\n    container1.scrollContainer.scrollLeft;\n  const scrollDY =\n    container2.scrollContainer.scrollTop - container1.scrollContainer.scrollTop;\n  return {\n    x: x + delta.x + scrollDX,\n    y: y + delta.y + scrollDY,\n  };\n}\n","import {\n  events,\n  vendorPrefix,\n  getPosition,\n  getElementMargin,\n  getEdgeOffset,\n  limit,\n  NodeType,\n} from '../utils';\nimport {closestRect, updateDistanceBetweenContainers} from './utils';\n\nexport default class DragLayer {\n  helper = null;\n  lists = [];\n\n  handleSortMove = (event) => {\n    // Prevent scrolling on mobile\n    event.preventDefault();\n    this.updatePosition(event);\n    this.updateTargetContainer(event);\n    if (this.targetList) {\n      this.targetList.handleSortMove(event);\n    }\n  };\n\n  handleSortEnd = (event) => {\n    if (this.listenerNode) {\n      events.move.forEach((eventName) =>\n        this.listenerNode.removeEventListener(eventName, this.handleSortMove),\n      );\n      events.end.forEach((eventName) =>\n        this.listenerNode.removeEventListener(eventName, this.handleSortEnd),\n      );\n    }\n\n    if (typeof this.onDragEnd === 'function') {\n      this.onDragEnd();\n    }\n    // Remove the helper from the DOM\n    if (this.helper) {\n      this.helper.parentNode.removeChild(this.helper);\n      this.helper = null;\n      this.targetList.handleSortEnd(event);\n    }\n\n    // Reset window scroll & container height diff\n    this.lists.forEach((list) => {\n      delete list.initialWindowScroll;\n    });\n  };\n\n  addRef(list) {\n    this.lists.push(list);\n  }\n\n  removeRef(list) {\n    const i = this.lists.indexOf(list);\n    if (i !== -1) {\n      this.lists.splice(i, 1);\n    }\n  }\n\n  setTranslateBoundaries(containerBoundingRect, list) {\n    const {useWindowAsScrollContainer} = list.props;\n\n    this.minTranslate = {};\n    this.maxTranslate = {};\n    if (this.axis.x) {\n      this.minTranslate.x =\n        (useWindowAsScrollContainer ? 0 : containerBoundingRect.left) -\n        this.boundingClientRect.left -\n        this.width / 2;\n      this.maxTranslate.x =\n        (useWindowAsScrollContainer\n          ? list.contentWindow.innerWidth\n          : containerBoundingRect.left + containerBoundingRect.width) -\n        this.boundingClientRect.left -\n        this.width / 2;\n    }\n    if (this.axis.y) {\n      this.minTranslate.y =\n        (useWindowAsScrollContainer ? 0 : containerBoundingRect.top) -\n        this.boundingClientRect.top -\n        this.height / 2;\n      this.maxTranslate.y =\n        (useWindowAsScrollContainer\n          ? list.contentWindow.innerHeight\n          : containerBoundingRect.top + containerBoundingRect.height) -\n        this.boundingClientRect.top -\n        this.height / 2;\n    }\n  }\n\n  startDrag(parent, list, event) {\n    const position = getPosition(event);\n    const activeNode = list.manager.getActive();\n\n    if (activeNode) {\n      const {axis, getHelperDimensions} = list.props;\n      const {node, collection} = activeNode;\n      const {index} = node.sortableInfo;\n      const margin = getElementMargin(node);\n      const containerBoundingRect = list.container.getBoundingClientRect();\n      const dimensions = getHelperDimensions({index, node, collection});\n\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.marginOffset = {\n        x: margin.left + margin.right,\n        y: Math.max(margin.top, margin.bottom),\n      };\n      this.boundingClientRect = node.getBoundingClientRect();\n      this.containerBoundingRect = containerBoundingRect;\n      this.targetList = list;\n\n      this.axis = {\n        x: axis.indexOf('x') >= 0,\n        y: axis.indexOf('y') >= 0,\n      };\n      this.offsetEdge = getEdgeOffset(node, list.container);\n\n      this.initialOffset = position;\n      this.distanceBetweenContainers = {\n        x: 0,\n        y: 0,\n      };\n\n      const fields = node.querySelectorAll('input, textarea, select, canvas');\n      const clonedNode = node.cloneNode(true);\n      const clonedFields = [\n        ...clonedNode.querySelectorAll('input, textarea, select, canvas'),\n      ];\n\n      clonedFields.forEach((field, i) => {\n        if (field.type !== 'file' && fields[index]) {\n          field.value = fields[i].value;\n        }\n\n        if (field.tagName === NodeType.Canvas) {\n          const destCtx = field.getContext('2d');\n          destCtx.drawImage(fields[index], 0, 0);\n        }\n      });\n\n      this.helper = parent.appendChild(clonedNode);\n\n      this.helper.style.position = 'fixed';\n      this.helper.style.top = `${this.boundingClientRect.top - margin.top}px`;\n      this.helper.style.left = `${this.boundingClientRect.left -\n        margin.left}px`;\n      this.helper.style.width = `${this.width}px`;\n      this.helper.style.height = `${this.height}px`;\n      this.helper.style.boxSizing = 'border-box';\n      this.helper.style.pointerEvents = 'none';\n\n      this.setTranslateBoundaries(containerBoundingRect, list);\n\n      this.listenerNode = event.touches ? node : list.contentWindow;\n      events.move.forEach((eventName) =>\n        this.listenerNode.addEventListener(\n          eventName,\n          this.handleSortMove,\n          false,\n        ),\n      );\n      events.end.forEach((eventName) =>\n        this.listenerNode.addEventListener(\n          eventName,\n          this.handleSortEnd,\n          false,\n        ),\n      );\n\n      return activeNode;\n    }\n    return false;\n  }\n\n  stopDrag() {\n    this.handleSortEnd();\n  }\n\n  updatePosition(event) {\n    const {lockAxis, lockToContainerEdges} = this.targetList.props;\n    const offset = getPosition(event);\n    const translate = {\n      x: offset.x - this.initialOffset.x,\n      y: offset.y - this.initialOffset.y,\n    };\n    // Adjust for window scroll\n    translate.y -= window.pageYOffset - this.targetList.initialWindowScroll.top;\n    translate.x -=\n      window.pageXOffset - this.targetList.initialWindowScroll.left;\n\n    this.translate = translate;\n    this.delta = offset;\n\n    if (lockToContainerEdges) {\n      const [\n        minLockOffset,\n        maxLockOffset,\n      ] = this.targetList.getLockPixelOffsets();\n      const minOffset = {\n        x: this.width / 2 - minLockOffset.x,\n        y: this.height / 2 - minLockOffset.y,\n      };\n      const maxOffset = {\n        x: this.width / 2 - maxLockOffset.x,\n        y: this.height / 2 - maxLockOffset.y,\n      };\n\n      translate.x = limit(\n        this.minTranslate.x + minOffset.x,\n        this.maxTranslate.x - maxOffset.x,\n        translate.x,\n      );\n      translate.y = limit(\n        this.minTranslate.y + minOffset.y,\n        this.maxTranslate.y - maxOffset.y,\n        translate.y,\n      );\n    }\n\n    if (lockAxis === 'x') {\n      translate.y = 0;\n    } else if (lockAxis === 'y') {\n      translate.x = 0;\n    }\n\n    this.helper.style[`${vendorPrefix}Transform`] = `translate3d(${\n      translate.x\n    }px,${translate.y}px, 0)`;\n  }\n\n  updateTargetContainer(event) {\n    const {x, y} = this.delta;\n    const originList = this.targetList;\n    const targetList = this.lists[\n      closestRect(x, y, this.lists.map((list) => list.container))\n    ];\n    const {item} = this.targetList.manager.active;\n    this.active = item;\n    if (targetList !== originList) {\n      this.targetList = targetList;\n\n      // Store initial scroll and dimensions of origin list, and initial\n      // dimensions of target list. This is to later accommodate height changes\n      // in both lists when items are added or removed during the DND operation.\n      const originListInitialWindowScroll = originList.initialWindowScroll;\n      const cachedOriginListRect = originList.container.getBoundingClientRect();\n      const cachedTargetListRect = targetList.container.getBoundingClientRect();\n\n      originList.handleSortEnd(event, targetList);\n\n      this.setTranslateBoundaries(\n        targetList.container.getBoundingClientRect(),\n        targetList,\n      );\n      this.targetList.manager.active = {\n        ...targetList.getClosestNode(event),\n        item,\n      };\n      targetList.handlePress(event);\n\n      // Override initial scroll to use scroll of origin list\n      this.targetList.initialWindowScroll = originListInitialWindowScroll;\n\n      this.distanceBetweenContainers = updateDistanceBetweenContainers(\n        this.distanceBetweenContainers,\n        targetList,\n        originList,\n      );\n\n      const targetListRect = targetList.container.getBoundingClientRect();\n\n      // If we're moving up the container ...\n      if (targetListRect.top < cachedOriginListRect.top) {\n        // Calculate any height difference that has occurred on the target container during the DND\n        const targetListContainerHeightDelta = Math.abs(\n          cachedTargetListRect.height - targetListRect.height,\n        );\n        this.distanceBetweenContainers.y += targetListContainerHeightDelta;\n      }\n    }\n  }\n}\n","export default class Manager {\n  refs = {};\n\n  add(collection, ref) {\n    if (!this.refs[collection]) {\n      this.refs[collection] = [];\n    }\n\n    this.refs[collection].push(ref);\n  }\n\n  remove(collection, ref) {\n    const index = this.getIndex(collection, ref);\n\n    if (index !== -1) {\n      this.refs[collection].splice(index, 1);\n    }\n  }\n\n  isActive() {\n    return this.active;\n  }\n\n  getActive() {\n    if (!this.active) {\n      return null;\n    }\n    const activeRef = this.refs[this.active.collection];\n    if (!activeRef) {\n      return null;\n    }\n    return (\n      activeRef.find(\n        // eslint-disable-next-line eqeqeq\n        ({node}) => node.sortableInfo.index == this.active.index,\n      ) || activeRef.slice(-1).pop()\n    );\n  }\n\n  getIndex(collection, ref) {\n    return this.refs[collection].indexOf(ref);\n  }\n\n  getOrderedRefs(collection = this.active.collection) {\n    return this.refs[collection].sort(sortByIndex);\n  }\n}\n\nfunction sortByIndex(\n  {\n    node: {\n      sortableInfo: {index: index1},\n    },\n  },\n  {\n    node: {\n      sortableInfo: {index: index2},\n    },\n  },\n) {\n  return index1 - index2;\n}\n","import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport {findDOMNode} from 'react-dom';\nimport invariant from 'invariant';\nimport findIndex from 'lodash/findIndex';\nimport isPlainObject from 'lodash/isPlainObject';\nimport DragLayer from '../DragLayer';\nimport Manager from '../Manager';\nimport {\n  closest,\n  events,\n  vendorPrefix,\n  getEdgeOffset,\n  getLockPixelOffset,\n  getPosition,\n  isTouchEvent,\n  provideDisplayName,\n  omit,\n} from '../utils';\nimport {closestRect} from '../DragLayer/utils';\nimport 'classlist-polyfill';\n\nexport default function sortableContainer(\n  WrappedComponent,\n  config = {withRef: false},\n) {\n  return class WithSortableContainer extends React.Component {\n    constructor(props) {\n      super(props);\n      this.dragLayer = props.dragLayer || new DragLayer();\n      this.dragLayer.addRef(this);\n      this.dragLayer.onDragEnd = props.onDragEnd;\n      this.manager = new Manager();\n      this.events = {\n        start: this.handleStart,\n        move: this.handleMove,\n        end: this.handleEnd,\n      };\n\n      invariant(\n        !(props.distance && props.pressDelay),\n        'Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.',\n      );\n\n      this.state = {};\n      this.sorting = false;\n    }\n\n    static displayName = provideDisplayName('sortableList', WrappedComponent);\n\n    static defaultProps = {\n      axis: 'y',\n      transitionDuration: 300,\n      pressDelay: 0,\n      pressThreshold: 5,\n      distance: 0,\n      useWindowAsScrollContainer: false,\n      hideSortableGhost: true,\n      animateNodes: true,\n      shouldCancelStart(event) {\n        // Cancel sorting if the event target is an `input`, `textarea`, `select` or `option`\n        const disabledElements = [\n          'input',\n          'textarea',\n          'select',\n          'option',\n          'button',\n        ];\n\n        if (\n          disabledElements.indexOf(event.target.tagName.toLowerCase()) !== -1\n        ) {\n          // Return true to cancel sorting\n          return true;\n        }\n\n        return false;\n      },\n      lockToContainerEdges: false,\n      lockOffset: '50%',\n      getHelperDimensions: ({node}) => ({\n        width: node.offsetWidth,\n        height: node.offsetHeight,\n      }),\n    };\n\n    static propTypes = {\n      axis: PropTypes.oneOf(['x', 'y', 'xy']),\n      distance: PropTypes.number,\n      dragLayer: PropTypes.object,\n      lockAxis: PropTypes.string,\n      helperClass: PropTypes.string,\n      transitionDuration: PropTypes.number,\n      contentWindow: PropTypes.any,\n      updateBeforeSortStart: PropTypes.func,\n      onSortStart: PropTypes.func,\n      onSortMove: PropTypes.func,\n      onSortOver: PropTypes.func,\n      onSortEnd: PropTypes.func,\n      onDragEnd: PropTypes.func,\n      shouldCancelStart: PropTypes.func,\n      pressDelay: PropTypes.number,\n      pressThreshold: PropTypes.number,\n      useDragHandle: PropTypes.bool,\n      animateNodes: PropTypes.bool,\n      useWindowAsScrollContainer: PropTypes.bool,\n      hideSortableGhost: PropTypes.bool,\n      lockToContainerEdges: PropTypes.bool,\n      lockOffset: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.string,\n        PropTypes.arrayOf(\n          PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n        ),\n      ]),\n      getContainer: PropTypes.func,\n      getHelperDimensions: PropTypes.func,\n      helperContainer: PropTypes.instanceOf(HTMLElement),\n    };\n\n    static childContextTypes = {\n      manager: PropTypes.object.isRequired,\n    };\n\n    getChildContext() {\n      return {\n        manager: this.manager,\n      };\n    }\n\n    componentDidMount() {\n      const {useWindowAsScrollContainer} = this.props;\n\n      /*\n       *  Set our own default rather than using defaultProps because Jest\n       *  snapshots will serialize window, causing a RangeError\n       *  https://github.com/clauderic/react-sortable-hoc/issues/249\n       */\n\n      const container = this.getContainer();\n\n      Promise.resolve(container).then((containerNode) => {\n        this.container = containerNode;\n        this.document = this.container.ownerDocument || document;\n\n        const contentWindow =\n          this.props.contentWindow || this.document.defaultView || window;\n\n        this.contentWindow =\n          typeof contentWindow === 'function' ? contentWindow() : contentWindow;\n        this.scrollContainer = useWindowAsScrollContainer\n          ? this.document.scrollingElement || this.document.documentElement\n          : this.container;\n        this.initialScroll = {\n          top: this.scrollContainer.scrollTop,\n          left: this.scrollContainer.scrollLeft,\n        };\n\n        for (const key in this.events) {\n          if (this.events.hasOwnProperty(key)) {\n            events[key].forEach((eventName) =>\n              this.container.addEventListener(\n                eventName,\n                this.events[key],\n                false,\n              ),\n            );\n          }\n        }\n      });\n    }\n\n    componentWillUnmount() {\n      this.dragLayer.removeRef(this);\n      if (this.container) {\n        for (const key in this.events) {\n          if (this.events.hasOwnProperty(key)) {\n            events[key].forEach((eventName) =>\n              this.container.removeEventListener(eventName, this.events[key]),\n            );\n          }\n        }\n      }\n    }\n\n    componentWillReceiveProps(nextProps) {\n      const {active} = this.manager;\n      if (!active) {\n        return;\n      }\n      this.checkActiveIndex(nextProps);\n    }\n\n    checkActiveIndex = (nextProps) => {\n      const {items} = nextProps || this.props;\n      const {item} = this.manager.active;\n\n      // If sortable item is an object, find item that match id\n      // Otherwise let findIndex predicate on item\n      const newIndex = isPlainObject(item)\n        ? findIndex(items, (obj) => obj.id === item.id)\n        : findIndex(items, item);\n\n      if (newIndex === -1) {\n        this.dragLayer.stopDrag();\n        return;\n      }\n      this.manager.active.index = newIndex;\n      this.index = newIndex;\n    };\n\n    handleStart = (event) => {\n      const {distance, shouldCancelStart, items} = this.props;\n\n      if (event.button === 2 || shouldCancelStart(event)) {\n        return;\n      }\n\n      this._touched = true;\n      this._pos = getPosition(event);\n\n      const node = closest(event.target, (el) => el.sortableInfo != null);\n\n      if (\n        node &&\n        node.sortableInfo &&\n        this.nodeIsChild(node) &&\n        !this.sorting\n      ) {\n        const {useDragHandle} = this.props;\n        const {index, collection} = node.sortableInfo;\n\n        if (\n          useDragHandle &&\n          !closest(event.target, (el) => el.sortableHandle != null)\n        ) {\n          return;\n        }\n\n        this.manager.active = {index, collection, item: items[index]};\n\n        /*\n         * Fixes a bug in Firefox where the :active state of anchor tags\n         * prevent subsequent 'mousemove' events from being fired\n         * (see https://github.com/clauderic/react-sortable-hoc/issues/118)\n         */\n        if (\n          !isTouchEvent(event) &&\n          event.target.tagName.toLowerCase() === 'a'\n        ) {\n          event.preventDefault();\n        }\n\n        if (!distance) {\n          if (this.props.pressDelay === 0) {\n            this.handlePress(event);\n          } else {\n            this.pressTimer = setTimeout(\n              () => this.handlePress(event),\n              this.props.pressDelay,\n            );\n          }\n        }\n      }\n    };\n\n    nodeIsChild = (node) => {\n      return node.sortableInfo.manager === this.manager;\n    };\n\n    handleMove = (event) => {\n      const {distance, pressThreshold} = this.props;\n      if (\n        !this.sorting &&\n        this._touched &&\n        !this._awaitingUpdateBeforeSortStart\n      ) {\n        const position = getPosition(event);\n        const delta = {\n          x: this._pos.x - position.x,\n          y: this._pos.y - position.y,\n        };\n        const combinedDelta = Math.abs(delta.x) + Math.abs(delta.y);\n\n        this.delta = delta;\n\n        if (\n          !distance &&\n          (!pressThreshold ||\n            (pressThreshold && combinedDelta >= pressThreshold))\n        ) {\n          clearTimeout(this.cancelTimer);\n          this.cancelTimer = setTimeout(this.cancel, 0);\n        } else if (\n          distance &&\n          combinedDelta >= distance &&\n          this.manager.isActive()\n        ) {\n          this.handlePress(event);\n        }\n      }\n    };\n\n    handleEnd = () => {\n      this._touched = false;\n      this.cancel();\n    };\n\n    cancel = () => {\n      const {distance} = this.props;\n\n      if (!this.sorting) {\n        if (!distance) {\n          clearTimeout(this.pressTimer);\n        }\n        this.manager.active = null;\n      }\n    };\n\n    handlePress = async (event) => {\n      let active = null;\n      if (this.dragLayer.helper) {\n        if (this.manager.active) {\n          this.checkActiveIndex();\n          active = this.manager.getActive();\n        }\n      } else {\n        active = this.dragLayer.startDrag(this.document.body, this, event);\n      }\n\n      if (active) {\n        const {\n          axis,\n          helperClass,\n          hideSortableGhost,\n          updateBeforeSortStart,\n          onSortStart,\n        } = this.props;\n        const {node, collection} = active;\n        const {index} = node.sortableInfo;\n\n        if (typeof updateBeforeSortStart === 'function') {\n          this._awaitingUpdateBeforeSortStart = true;\n\n          try {\n            await updateBeforeSortStart({node, index, collection}, event);\n          } finally {\n            this._awaitingUpdateBeforeSortStart = false;\n          }\n        }\n\n        this.index = index;\n        this.newIndex = index;\n        this.axis = {\n          x: axis.indexOf('x') >= 0,\n          y: axis.indexOf('y') >= 0,\n        };\n\n        this.initialScroll = {\n          top: this.container.scrollTop,\n          left: this.container.scrollLeft,\n        };\n\n        this.initialWindowScroll = {\n          top: window.pageYOffset,\n          left: window.pageXOffset,\n        };\n\n        if (hideSortableGhost) {\n          this.sortableGhost = node;\n          node.style.visibility = 'hidden';\n          node.style.opacity = 0;\n        }\n\n        if (helperClass) {\n          this.dragLayer.helper.classList.add(...helperClass.split(' '));\n        }\n\n        this.sorting = true;\n        this.sortingIndex = index;\n\n        if (onSortStart) {\n          onSortStart({node, index, collection}, event);\n        }\n      }\n    };\n\n    _handleSortMove = (event) => {\n      // animate nodes if required\n      if (this.checkActive(event)) {\n        this.animateNodes();\n        this.autoscroll();\n      }\n\n      if (window.requestAnimationFrame) {\n        this.sortMoveAF = null;\n      } else {\n        // aim for 60 fps\n        setTimeout(() => {\n          this.sortMoveAF = null;\n        }, 1000 / 60);\n      }\n    };\n\n    handleSortMove = (event) => {\n      const {onSortMove} = this.props;\n      // Prevent scrolling on mobile\n      event.preventDefault();\n\n      if (this.sortMoveAF) {\n        return;\n      }\n\n      if (window.requestAnimationFrame) {\n        this.sortMoveAF = window.requestAnimationFrame(this._handleSortMove);\n      } else {\n        this.sortMoveAF = true;\n        // call inner function now if no animation frame\n        this._handleSortMove();\n      }\n\n      if (onSortMove) {\n        onSortMove(event);\n      }\n    };\n\n    handleSortEnd = (event, newList = null) => {\n      const {hideSortableGhost, onSortEnd} = this.props;\n      if (!this.manager.active) {\n        return;\n      }\n      const {collection} = this.manager.active;\n\n      // Remove the move handler if there's a frame that hasn't run yet.\n      if (window.cancelAnimationFrame && this.sortMoveAF) {\n        window.cancelAnimationFrame(this.sortMoveAF);\n        this.sortMoveAF = null;\n      }\n\n      if (hideSortableGhost && this.sortableGhost) {\n        this.sortableGhost.style.visibility = '';\n        this.sortableGhost.style.opacity = '';\n      }\n\n      const nodes = this.manager.refs[collection];\n      for (let i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n        const el = node.node;\n\n        // Clear the cached offsetTop / offsetLeft value\n        node.edgeOffset = null;\n\n        // Remove the transforms / transitions\n        el.style[`${vendorPrefix}Transform`] = '';\n        el.style[`${vendorPrefix}TransitionDuration`] = '';\n      }\n\n      // Stop autoscroll\n      clearInterval(this.autoscrollInterval);\n      this.autoscrollInterval = null;\n\n      // Update state\n      this.manager.active = null;\n\n      this.sorting = false;\n      this.sortingIndex = null;\n\n      if (typeof onSortEnd === 'function') {\n        // get the index in the new list\n        if (newList) {\n          this.newIndex = newList.getClosestNode(event).index;\n        }\n\n        onSortEnd(\n          {\n            oldIndex: this.index,\n            newIndex: this.newIndex,\n            newList,\n            collection,\n          },\n          event,\n        );\n      }\n\n      this._touched = false;\n    };\n\n    handleSortSwap = (index, item) => {\n      const {onSortSwap} = this.props;\n      if (typeof onSortSwap === 'function') {\n        onSortSwap({\n          index,\n          item,\n        });\n      }\n    };\n\n    getLockPixelOffsets() {\n      const {width, height} = this.dragLayer;\n      const {lockOffset} = this.props;\n      const offsets = Array.isArray(lockOffset)\n        ? lockOffset\n        : [lockOffset, lockOffset];\n\n      invariant(\n        offsets.length === 2,\n        'lockOffset prop of SortableContainer should be a single ' +\n          'value or an array of exactly two values. Given %s',\n        lockOffset,\n      );\n\n      const [minLockOffset, maxLockOffset] = offsets;\n\n      return [\n        getLockPixelOffset({lockOffset: minLockOffset, width, height}),\n        getLockPixelOffset({lockOffset: maxLockOffset, width, height}),\n      ];\n    }\n\n    getClosestNode = (event) => {\n      const position = getPosition(event);\n      // eslint-disable-next-line\n      let closestNodes = [];\n      // eslint-disable-next-line\n      let closestCollections = [];\n\n      Object.keys(this.manager.refs).forEach((collection) => {\n        const nodes = this.manager.refs[collection].map((ref) => ref.node);\n        if (nodes && nodes.length > 0) {\n          closestNodes.push(nodes[closestRect(position.x, position.y, nodes)]);\n          closestCollections.push(collection);\n        }\n      });\n      const index = closestRect(position.x, position.y, closestNodes);\n      const collection = closestCollections[index];\n      if (collection === undefined) {\n        return {\n          collection,\n          index: 0,\n        };\n      }\n      const finalNodes = this.manager.refs[collection].map((ref) => ref.node);\n      const finalIndex = finalNodes.indexOf(closestNodes[index]);\n      const node = closestNodes[index];\n      const rect = node.getBoundingClientRect();\n      return {\n        collection,\n        index: finalIndex + (position.y > rect.bottom ? 1 : 0),\n      };\n    };\n\n    checkActive = (event) => {\n      const active = this.manager.active;\n      if (!active) {\n        // find closest collection\n        const node = closest(event.target, (el) => el.sortableInfo != null);\n        if (node && node.sortableInfo) {\n          const pos = getPosition(event);\n          const {collection} = node.sortableInfo;\n          const nodes = this.manager.refs[collection].map((ref) => ref.node);\n          // find closest index in collection\n          if (nodes) {\n            const index = closestRect(pos.x, pos.y, nodes);\n            this.manager.active = {\n              index,\n              collection,\n              item: this.props.items[index],\n            };\n            this.handlePress(event);\n          }\n        }\n        return false;\n      }\n      return true;\n    };\n\n    animateNodes() {\n      if (!this.axis) {\n        return;\n      }\n      const {\n        transitionDuration,\n        hideSortableGhost,\n        onSortOver,\n        animateNodes,\n      } = this.props;\n      const nodes = this.manager.getOrderedRefs();\n      const containerScrollDelta = {\n        left: this.container.scrollLeft - this.initialScroll.left,\n        top: this.container.scrollTop - this.initialScroll.top,\n      };\n      const sortingOffset = {\n        left:\n          this.dragLayer.offsetEdge.left -\n          this.dragLayer.distanceBetweenContainers.x +\n          this.dragLayer.translate.x +\n          containerScrollDelta.left,\n        top:\n          this.dragLayer.offsetEdge.top -\n          this.dragLayer.distanceBetweenContainers.y +\n          this.dragLayer.translate.y +\n          containerScrollDelta.top,\n      };\n      const windowScrollDelta = {\n        top: window.pageYOffset - this.initialWindowScroll.top,\n        left: window.pageXOffset - this.initialWindowScroll.left,\n      };\n      const prevIndex = this.newIndex;\n      this.newIndex = null;\n\n      for (let i = 0, len = nodes.length; i < len; i++) {\n        const {node} = nodes[i];\n        const index = node.sortableInfo.index;\n        const width = node.offsetWidth;\n        const height = node.offsetHeight;\n        const offset = {\n          width:\n            this.dragLayer.width > width ? width / 2 : this.dragLayer.width / 2,\n          height:\n            this.dragLayer.height > height\n              ? height / 2\n              : this.dragLayer.height / 2,\n        };\n\n        const translate = {\n          x: 0,\n          y: 0,\n        };\n        let {edgeOffset} = nodes[i];\n\n        // If we haven't cached the node's offsetTop / offsetLeft value\n        if (!edgeOffset) {\n          edgeOffset = getEdgeOffset(node, this.container);\n          nodes[i].edgeOffset = edgeOffset;\n        }\n\n        // Get a reference to the next and previous node\n        const nextNode = i < nodes.length - 1 && nodes[i + 1];\n        const prevNode = i > 0 && nodes[i - 1];\n\n        // Also cache the next node's edge offset if needed.\n        // We need this for calculating the animation in a grid setup\n        if (nextNode && !nextNode.edgeOffset) {\n          nextNode.edgeOffset = getEdgeOffset(nextNode.node, this.container);\n        }\n\n        // If the node is the one we're currently animating, skip it\n        if (index === this.index) {\n          if (hideSortableGhost) {\n            /*\n             * With windowing libraries such as `react-virtualized`, the sortableGhost\n             * node may change while scrolling down and then back up (or vice-versa),\n             * so we need to update the reference to the new node just to be safe.\n             */\n            this.sortableGhost = node;\n            node.style.visibility = 'hidden';\n            node.style.opacity = 0;\n          }\n          continue;\n        }\n\n        if (transitionDuration) {\n          node.style[\n            `${vendorPrefix}TransitionDuration`\n          ] = `${transitionDuration}ms`;\n        }\n\n        if (this.axis.x) {\n          if (this.axis.y) {\n            // Calculations for a grid setup\n            if (\n              index < this.index &&\n              ((sortingOffset.left + windowScrollDelta.left - offset.width <=\n                edgeOffset.left &&\n                sortingOffset.top + windowScrollDelta.top <=\n                  edgeOffset.top + offset.height) ||\n                sortingOffset.top + windowScrollDelta.top + offset.height <=\n                  edgeOffset.top)\n            ) {\n              // If the current node is to the left on the same row, or above the node that's being dragged\n              // then move it to the right\n              translate.x =\n                this.dragLayer.width + this.dragLayer.marginOffset.x;\n              if (\n                edgeOffset.left + translate.x >\n                this.dragLayer.containerBoundingRect.width - offset.width\n              ) {\n                // If it moves passed the right bounds, then animate it to the first position of the next row.\n                // We just use the offset of the next node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = nextNode.edgeOffset.left - edgeOffset.left;\n                translate.y = nextNode.edgeOffset.top - edgeOffset.top;\n              }\n              if (this.newIndex === null) {\n                this.newIndex = index;\n              }\n            } else if (\n              index > this.index &&\n              ((sortingOffset.left + windowScrollDelta.left + offset.width >=\n                edgeOffset.left &&\n                sortingOffset.top + windowScrollDelta.top + offset.height >=\n                  edgeOffset.top) ||\n                sortingOffset.top + windowScrollDelta.top + offset.height >=\n                  edgeOffset.top + height)\n            ) {\n              // If the current node is to the right on the same row, or below the node that's being dragged\n              // then move it to the left\n              translate.x = -(\n                this.dragLayer.width + this.dragLayer.marginOffset.x\n              );\n              if (\n                edgeOffset.left + translate.x <\n                this.dragLayer.containerBoundingRect.left + offset.width\n              ) {\n                // If it moves passed the left bounds, then animate it to the last position of the previous row.\n                // We just use the offset of the previous node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = prevNode.edgeOffset.left - edgeOffset.left;\n                translate.y = prevNode.edgeOffset.top - edgeOffset.top;\n              }\n              this.newIndex = index;\n            }\n          } else {\n            if (\n              index > this.index &&\n              sortingOffset.left + windowScrollDelta.left + offset.width >=\n                edgeOffset.left\n            ) {\n              translate.x = -(\n                this.dragLayer.width + this.dragLayer.marginOffset.x\n              );\n              this.newIndex = index;\n            } else if (\n              index < this.index &&\n              sortingOffset.left + windowScrollDelta.left <=\n                edgeOffset.left + offset.width\n            ) {\n              translate.x =\n                this.dragLayer.width + this.dragLayer.marginOffset.x;\n\n              if (this.newIndex == null) {\n                this.newIndex = index;\n              }\n            }\n          }\n        } else if (this.axis.y) {\n          if (\n            index > this.index &&\n            sortingOffset.top + windowScrollDelta.top + offset.height >=\n              edgeOffset.top\n          ) {\n            translate.y = -(\n              this.dragLayer.height + this.dragLayer.marginOffset.y\n            );\n            this.newIndex = index;\n          } else if (\n            index < this.index &&\n            sortingOffset.top + windowScrollDelta.top <=\n              edgeOffset.top + offset.height\n          ) {\n            translate.y = this.dragLayer.height + this.dragLayer.marginOffset.y;\n            if (this.newIndex == null) {\n              this.newIndex = index;\n            }\n          }\n        }\n\n        // Translate the position of the given node\n        if (animateNodes) {\n          node.style[`${vendorPrefix}Transform`] = `translate3d(${\n            translate.x\n          }px,${translate.y}px,0)`;\n        }\n      }\n\n      if (this.newIndex == null) {\n        this.newIndex = this.index;\n      }\n\n      if (onSortOver && this.newIndex !== prevIndex) {\n        onSortOver({\n          newIndex: this.newIndex,\n          oldIndex: prevIndex,\n          index: this.index,\n          collection: this.manager.active.collection,\n        });\n      }\n    }\n\n    autoscroll = () => {\n      const translate = this.dragLayer.translate;\n      const direction = {\n        x: 0,\n        y: 0,\n      };\n      const speed = {\n        x: 1,\n        y: 1,\n      };\n      const acceleration = {\n        x: 10,\n        y: 10,\n      };\n\n      if (\n        translate.y >=\n        this.dragLayer.maxTranslate.y - this.dragLayer.height / 2\n      ) {\n        // Scroll Down\n        direction.y = 1;\n        speed.y =\n          acceleration.y *\n          Math.abs(\n            (this.dragLayer.maxTranslate.y -\n              this.dragLayer.height / 2 -\n              translate.y) /\n              this.dragLayer.height,\n          );\n      } else if (\n        translate.x >=\n        this.dragLayer.maxTranslate.x - this.dragLayer.width / 2\n      ) {\n        // Scroll Right\n        direction.x = 1;\n        speed.x =\n          acceleration.x *\n          Math.abs(\n            (this.dragLayer.maxTranslate.x -\n              this.dragLayer.width / 2 -\n              translate.x) /\n              this.dragLayer.width,\n          );\n      } else if (\n        translate.y <=\n        this.dragLayer.minTranslate.y + this.dragLayer.height / 2\n      ) {\n        // Scroll Up\n        direction.y = -1;\n        speed.y =\n          acceleration.y *\n          Math.abs(\n            (translate.y -\n              this.dragLayer.height / 2 -\n              this.dragLayer.minTranslate.y) /\n              this.dragLayer.height,\n          );\n      } else if (\n        translate.x <=\n        this.dragLayer.minTranslate.x + this.dragLayer.width / 2\n      ) {\n        // Scroll Left\n        direction.x = -1;\n        speed.x =\n          acceleration.x *\n          Math.abs(\n            (translate.x -\n              this.dragLayer.width / 2 -\n              this.dragLayer.minTranslate.x) /\n              this.dragLayer.width,\n          );\n      }\n\n      if (this.autoscrollInterval) {\n        clearInterval(this.autoscrollInterval);\n        this.autoscrollInterval = null;\n        this.isAutoScrolling = false;\n      }\n\n      if (direction.x !== 0 || direction.y !== 0) {\n        this.autoscrollInterval = setInterval(() => {\n          this.isAutoScrolling = true;\n          const offset = {\n            left: speed.x * direction.x,\n            top: speed.y * direction.y,\n          };\n          this.scrollContainer.scrollTop += offset.top;\n          this.scrollContainer.scrollLeft += offset.left;\n          this.animateNodes();\n        }, 5);\n      }\n    };\n\n    getWrappedInstance() {\n      invariant(\n        config.withRef,\n        'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call',\n      );\n\n      return this.refs.wrappedInstance;\n    }\n\n    getContainer() {\n      const {getContainer} = this.props;\n\n      if (typeof getContainer !== 'function') {\n        return findDOMNode(this);\n      }\n\n      return getContainer(\n        config.withRef ? this.getWrappedInstance() : undefined,\n      );\n    }\n\n    render() {\n      const ref = config.withRef ? 'wrappedInstance' : null;\n\n      return (\n        <WrappedComponent\n          ref={ref}\n          {...omit(\n            this.props,\n            'contentWindow',\n            'useWindowAsScrollContainer',\n            'distance',\n            'helperClass',\n            'hideSortableGhost',\n            'transitionDuration',\n            'useDragHandle',\n            'animateNodes',\n            'pressDelay',\n            'pressThreshold',\n            'shouldCancelStart',\n            'updateBeforeSortStart',\n            'onSortStart',\n            'onSortSwap',\n            'onSortMove',\n            'onSortEnd',\n            'axis',\n            'lockAxis',\n            'lockOffset',\n            'lockToContainerEdges',\n            'getContainer',\n            'getHelperDimensions',\n          )}\n        />\n      );\n    }\n\n    get helperContainer() {\n      return this.props.helperContainer || this.document.body;\n    }\n  };\n}\n","import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport {findDOMNode} from 'react-dom';\nimport invariant from 'invariant';\n\nimport {provideDisplayName, omit} from '../utils';\n\nexport default function sortableElement(\n  WrappedComponent,\n  config = {withRef: false},\n) {\n  return class WithSortableElement extends React.Component {\n    static displayName = provideDisplayName(\n      'sortableElement',\n      WrappedComponent,\n    );\n\n    static contextTypes = {\n      manager: PropTypes.object.isRequired,\n    };\n\n    static propTypes = {\n      index: PropTypes.number.isRequired,\n      collection: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n      disabled: PropTypes.bool,\n    };\n\n    static defaultProps = {\n      collection: 0,\n    };\n\n    componentDidMount() {\n      const {collection, disabled, index} = this.props;\n\n      if (!disabled) {\n        this.setDraggable(collection, index);\n      }\n    }\n\n    componentWillReceiveProps(nextProps) {\n      if (this.props.index !== nextProps.index && this.node) {\n        this.node.sortableInfo.index = nextProps.index;\n      }\n\n      if (this.props.disabled !== nextProps.disabled) {\n        const {collection, disabled, index} = nextProps;\n        if (disabled) {\n          this.removeDraggable(collection);\n        } else {\n          this.setDraggable(collection, index);\n        }\n      } else if (this.props.collection !== nextProps.collection) {\n        this.removeDraggable(this.props.collection);\n        this.setDraggable(nextProps.collection, nextProps.index);\n      }\n    }\n\n    componentWillUnmount() {\n      const {collection, disabled} = this.props;\n\n      if (!disabled) {\n        this.removeDraggable(collection);\n      }\n    }\n\n    setDraggable(collection, index) {\n      const node = findDOMNode(this);\n\n      node.sortableInfo = {\n        index,\n        collection,\n        manager: this.context.manager,\n      };\n\n      this.node = node;\n      this.ref = {node};\n      this.context.manager.add(collection, this.ref);\n    }\n\n    removeDraggable(collection) {\n      this.context.manager.remove(collection, this.ref);\n    }\n\n    getWrappedInstance() {\n      invariant(\n        config.withRef,\n        'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call',\n      );\n      return this.refs.wrappedInstance;\n    }\n\n    render() {\n      const ref = config.withRef ? 'wrappedInstance' : null;\n\n      return (\n        <WrappedComponent\n          ref={ref}\n          {...omit(this.props, 'collection', 'disabled', 'index')}\n        />\n      );\n    }\n  };\n}\n","import * as React from 'react';\nimport {findDOMNode} from 'react-dom';\nimport invariant from 'invariant';\n\nimport {provideDisplayName} from '../utils';\n\nexport default function sortableHandle(\n  WrappedComponent,\n  config = {withRef: false},\n) {\n  return class WithSortableHandle extends React.Component {\n    static displayName = provideDisplayName('sortableHandle', WrappedComponent);\n\n    componentDidMount() {\n      const node = findDOMNode(this);\n      node.sortableHandle = true;\n    }\n\n    getWrappedInstance() {\n      invariant(\n        config.withRef,\n        'To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call',\n      );\n      return this.refs.wrappedInstance;\n    }\n\n    render() {\n      const ref = config.withRef ? 'wrappedInstance' : null;\n\n      return <WrappedComponent ref={ref} {...this.props} />;\n    }\n  };\n}\n"],"names":["arrayMove","array","from","to","slice","splice","length","omit","obj","Object","keys","reduce","acc","key","keysToOmit","indexOf","const","events","start","move","end","vendorPrefix","window","document","styles","getComputedStyle","documentElement","pre","Array","prototype","call","join","match","OLink","toUpperCase","substr","closest","el","fn","parentNode","limit","min","max","value","Math","getPixelValue","stringValue","parseFloat","getElementMargin","element","style","top","marginTop","right","marginRight","bottom","marginBottom","left","marginLeft","provideDisplayName","prefix","Component","componentName","displayName","name","getPosition","event","touches","x","pageX","y","pageY","changedTouches","isTouchEvent","getEdgeOffset","node","parent","offset","undefined","nodeOffset","offsetTop","offsetLeft","getLockPixelOffset","width","height","offsetX","lockOffset","offsetY","unit","exec","invariant","isFinite","NodeType","Anchor","Button","Canvas","Input","Option","Textarea","Select","distanceRect","rect","pageXOffset","pageYOffset","dx","dy","sqrt","closestRect","containers","distances","map","container","getBoundingClientRect","getDelta","rect1","rect2","updateDistanceBetweenContainers","distance","container1","container2","delta","cont","scrollDX","scrollContainer","scrollLeft","scrollDY","scrollTop","DragLayer","helper","lists","handleSortMove","preventDefault","updatePosition","updateTargetContainer","this","targetList","handleSortEnd","listenerNode","forEach","eventName","removeEventListener","onDragEnd","removeChild","list","initialWindowScroll","addRef","push","removeRef","i","setTranslateBoundaries","containerBoundingRect","props","useWindowAsScrollContainer","minTranslate","maxTranslate","axis","boundingClientRect","contentWindow","innerWidth","innerHeight","startDrag","position","activeNode","manager","getActive","getHelperDimensions","collection","sortableInfo","index","margin","dimensions","marginOffset","offsetEdge","initialOffset","distanceBetweenContainers","fields","querySelectorAll","clonedNode","cloneNode","clonedFields","field","type","tagName","destCtx","getContext","drawImage","appendChild","boxSizing","pointerEvents","addEventListener","stopDrag","lockAxis","lockToContainerEdges","translate","getLockPixelOffsets","minLockOffset","maxLockOffset","minOffset","maxOffset","originList","active","item","originListInitialWindowScroll","cachedOriginListRect","cachedTargetListRect","getClosestNode","handlePress","targetListRect","targetListContainerHeightDelta","abs","Manager","refs","add","ref","remove","getIndex","isActive","activeRef","find","pop","getOrderedRefs","sort","sortByIndex","index2","index1","sortableContainer","WrappedComponent","config","withRef","checkActiveIndex","nextProps","items","newIndex","isPlainObject","findIndex","id","dragLayer","handleStart","shouldCancelStart","button","_touched","_pos","target","nodeIsChild","sorting","useDragHandle","sortableHandle","toLowerCase","pressDelay","pressTimer","setTimeout","handleMove","pressThreshold","_awaitingUpdateBeforeSortStart","combinedDelta","clearTimeout","cancelTimer","cancel","handleEnd","body","initialScroll","hideSortableGhost","sortableGhost","visibility","opacity","helperClass","classList","split","sortingIndex","onSortStart","updateBeforeSortStart","_handleSortMove","checkActive","animateNodes","autoscroll","requestAnimationFrame","sortMoveAF","onSortMove","newList","onSortEnd","cancelAnimationFrame","nodes","let","len","edgeOffset","clearInterval","autoscrollInterval","oldIndex","handleSortSwap","onSortSwap","closestNodes","closestCollections","finalNodes","finalIndex","pos","direction","speed","acceleration","isAutoScrolling","setInterval","state","getChildContext","componentDidMount","getContainer","Promise","resolve","then","containerNode","ownerDocument","defaultView","scrollingElement","hasOwnProperty","componentWillUnmount","componentWillReceiveProps","offsets","isArray","transitionDuration","onSortOver","containerScrollDelta","sortingOffset","windowScrollDelta","prevIndex","offsetWidth","offsetHeight","nextNode","prevNode","getWrappedInstance","wrappedInstance","findDOMNode","render","React.createElement","helperContainer","defaultProps","disabledElements","propTypes","PropTypes","oneOf","number","object","string","any","func","bool","oneOfType","arrayOf","instanceOf","HTMLElement","childContextTypes","isRequired","sortableElement","disabled","setDraggable","removeDraggable","context","contextTypes"],"mappings":"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"}